#!/usr/bin/env python3
"""
Generate TypeScript code from JSON definitions.

This script reads JSON definitions and generates TypeScript modules.
"""

import json
from pathlib import Path
from textwrap import dedent, indent


def escape_ts_string(s: str) -> str:
    """Escape string for TypeScript single-quoted strings."""
    return s.replace("'", "\\'")


# Map parameter indices to their names
PARAM_NAMES = [
    "honesty_bias",
    "work_tendency",
    "neighbor_help_bias",
    "own_house_priority",
    "risk_aversion",
    "coordination_weight",
    "exploration_rate",
    "fatigue_memory",
    "rest_reward_bias",
    "altruism_factor",
]

# Parameter descriptions (from existing archetypes.ts)
PARAM_DESCRIPTIONS = {
    "honesty_bias": {
        "label": "Honesty",
        "description": "Probability of truthful signaling (0 = always lies, 1 = always truthful)",
    },
    "work_tendency": {
        "label": "Work Tendency",
        "description": "Base tendency to work vs. rest (0 = never works, 1 = always works)",
    },
    "neighbor_help_bias": {
        "label": "Neighbor Help",
        "description": "Preference for helping neighbor houses (0 = ignores neighbors, 1 = prioritizes neighbors)",
    },
    "own_house_priority": {
        "label": "Self-Preservation",
        "description": "Priority given to own houses (0 = ignores own houses, 1 = only cares about own houses)",
    },
    "risk_aversion": {
        "label": "Risk Aversion",
        "description": "Sensitivity to burning houses and fire spread (0 = ignores risk, 1 = highly cautious)",
    },
    "coordination_weight": {
        "label": "Trust in Signals",
        "description": "Trust in others' signals for decision-making (0 = ignores signals, 1 = fully trusts)",
    },
    "exploration_rate": {
        "label": "Randomness",
        "description": "Amount of random exploration in decisions (0 = deterministic, 1 = fully random)",
    },
    "fatigue_memory": {
        "label": "Consistency",
        "description": "Inertia to repeat previous actions (0 = no memory, 1 = highly consistent)",
    },
    "rest_reward_bias": {
        "label": "Rest Preference",
        "description": "Intrinsic preference for resting (0 = no preference, 1 = strongly prefers rest)",
    },
    "altruism_factor": {
        "label": "Altruism",
        "description": "Willingness to help others at personal cost (0 = selfish, 1 = maximally altruistic)",
    },
}


def generate_archetypes(json_path: Path, output_path: Path):
    """Generate archetypes.generated.ts from JSON."""
    with open(json_path) as f:
        data = json.load(f)

    archetypes = data["archetypes"]

    # Generate TypeScript code
    code = dedent(
        """\
    /**
     * Archetype parameter definitions - GENERATED FILE
     *
     * This file is automatically generated from definitions/archetypes.json
     * DO NOT EDIT MANUALLY - changes will be overwritten
     *
     * To modify archetypes, edit definitions/archetypes.json and run:
     *     python scripts/generate_typescript.py
     */

    export interface ArchetypeParams {
      honesty_bias: number;
      work_tendency: number;
      neighbor_help_bias: number;
      own_house_priority: number;
      risk_aversion: number;
      coordination_weight: number;
      exploration_rate: number;
      fatigue_memory: number;
      rest_reward_bias: number;
      altruism_factor: number;
    }

    export interface Archetype {
      id: string;
      name: string;
      description: string;
      params: ArchetypeParams;
    }

    """
    )

    # Generate ARCHETYPES constant
    code += "export const ARCHETYPES: Record<string, Archetype> = {\n"

    for name, spec in archetypes.items():
        # Convert snake_case to Title Case for display name
        display_name = " ".join(word.capitalize() for word in name.split("_"))

        code += f"  {name}: {{\n"
        code += f"    id: '{name}',\n"
        code += f"    name: '{display_name}',\n"
        code += f"    description: '{escape_ts_string(spec['description'])}',\n"
        code += f"    params: {{\n"

        # Map parameter array to named parameters
        for i, value in enumerate(spec["params"]):
            param_name = PARAM_NAMES[i]
            code += f"      {param_name}: {value},\n"

        code += f"    }},\n"
        code += f"  }},\n"

    code += "};\n\n"

    # Generate PARAMETER_DESCRIPTIONS
    code += "export const PARAMETER_DESCRIPTIONS: Record<keyof ArchetypeParams, { label: string; description: string }> = {\n"
    for param_name, desc_info in PARAM_DESCRIPTIONS.items():
        code += f"  {param_name}: {{\n"
        code += f"    label: '{escape_ts_string(desc_info['label'])}',\n"
        code += f"    description: '{escape_ts_string(desc_info['description'])}',\n"
        code += f"  }},\n"
    code += "};\n\n"

    # Generate helper functions
    code += dedent(
        """
    export function getArchetype(id: string): Archetype | undefined {
      return ARCHETYPES[id.toLowerCase()];
    }

    export function listArchetypes(): Archetype[] {
      return Object.values(ARCHETYPES);
    }
    """
    )

    # Write output
    output_path.parent.mkdir(parents=True, exist_ok=True)
    with open(output_path, "w") as f:
        f.write(code)

    print(f"✓ Generated {output_path}")


def generate_scenarios(json_path: Path, output_path: Path):
    """Generate scenarioGenerator.generated.ts from JSON."""
    with open(json_path) as f:
        data = json.load(f)

    scenarios = data["scenarios"]

    # Generate TypeScript code
    code = dedent(
        """\
    /**
     * Scenario Generator - GENERATED FILE
     *
     * This file is automatically generated from definitions/scenarios.json
     * DO NOT EDIT MANUALLY - changes will be overwritten
     *
     * To modify scenarios, edit definitions/scenarios.json and run:
     *     python scripts/generate_typescript.py
     *
     * Generates randomized game scenarios for tournaments
     */

    import type { Scenario } from '../types';

    /**
     * Scenario type categories
     * Must match bucket_brigade/envs/scenarios.py SCENARIO_REGISTRY
     */
    export const SCENARIO_TYPES = {
    """
    )

    # Generate SCENARIO_TYPES constant
    for name in scenarios.keys():
        constant_name = name.upper()
        code += f"  {constant_name}: '{name}',\n"

    code += "} as const;\n\n"
    code += "export type ScenarioType = (typeof SCENARIO_TYPES)[keyof typeof SCENARIO_TYPES];\n\n"

    # Generate SCENARIO_TEMPLATES
    code += dedent(
        """
    /**
     * Scenario type definitions with parameter ranges
     * Parameters must match bucket_brigade/envs/scenarios.py exactly
     */
    const SCENARIO_TEMPLATES: Record<
      ScenarioType,
      {
        name: string;
        description: string;
        parameters: Partial<Scenario>;
      }
    > = {
    """
    )

    for name, spec in scenarios.items():
        constant_name = name.upper()
        # Convert snake_case to Title Case for display name
        display_name = " ".join(word.capitalize() for word in name.split("_"))

        code += f"  [SCENARIO_TYPES.{constant_name}]: {{\n"
        code += f"    name: '{display_name}',\n"
        code += f"    description: '{escape_ts_string(spec['description'])}',\n"
        code += f"    parameters: {{\n"
        code += f"      beta: {spec['beta']},\n"
        code += f"      kappa: {spec['kappa']},\n"
        code += f"      A: {spec['A']},\n"
        code += f"      L: {spec['L']},\n"
        code += f"      c: {spec['c']},\n"
        code += f"      rho_ignite: {spec['rho_ignite']},\n"
        code += f"      N_min: {spec['N_min']},\n"
        code += f"      p_spark: {spec['p_spark']},\n"
        code += f"      N_spark: {spec['N_spark']},\n"
        code += f"    }},\n"
        code += f"  }},\n"

    code += "};\n\n"

    # Generate helper functions (keep existing logic)
    code += dedent(
        """
    /**
     * Generate a random scenario of a specific type
     */
    export function generateScenario(
      type: ScenarioType,
      numAgents: number,
      _seed?: number,
    ): Scenario {
      const template = SCENARIO_TEMPLATES[type];

      // Add small random variations to parameters
      const variance = 0.1; // 10% variation
      const randomize = (base: number) => {
        const factor = 1 + (Math.random() - 0.5) * variance;
        return Math.max(0, base * factor);
      };

      return {
        beta: randomize(template.parameters.beta ?? 0.25),
        kappa: randomize(template.parameters.kappa ?? 0.5),
        A: template.parameters.A ?? 100,
        L: template.parameters.L ?? 100,
        c: randomize(template.parameters.c ?? 0.5),
        rho_ignite: randomize(template.parameters.rho_ignite ?? 0.2),
        N_min: template.parameters.N_min ?? 12,
        p_spark: randomize(template.parameters.p_spark ?? 0.02),
        N_spark: template.parameters.N_spark ?? 12,
        num_agents: numAgents,
      };
    }

    /**
     * Generate random scenario (any type)
     */
    export function generateRandomScenario(numAgents: number, seed?: number): Scenario {
      const types = Object.values(SCENARIO_TYPES);
      const randomType = types[Math.floor(Math.random() * types.length)];
      return generateScenario(randomType, numAgents, seed);
    }

    /**
     * Generate balanced distribution of scenarios
     */
    export function generateScenarioSet(
      numScenarios: number,
      numAgents: number,
      seed?: number,
    ): Array<{ scenario: Scenario; type: ScenarioType }> {
      const scenarios: Array<{ scenario: Scenario; type: ScenarioType }> = [];
      const types = Object.values(SCENARIO_TYPES);

      // Distribute evenly across scenario types
      for (let i = 0; i < numScenarios; i++) {
        const type = types[i % types.length];
        scenarios.push({
          scenario: generateScenario(type, numAgents, seed),
          type,
        });
      }

      // Shuffle for randomness
      for (let i = scenarios.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [scenarios[i], scenarios[j]] = [scenarios[j], scenarios[i]];
      }

      return scenarios;
    }

    /**
     * Get scenario template info
     */
    export function getScenarioTemplate(type: ScenarioType) {
      return SCENARIO_TEMPLATES[type];
    }

    /**
     * Get all scenario types
     */
    export function getAllScenarioTypes(): ScenarioType[] {
      return Object.values(SCENARIO_TYPES);
    }
    """
    )

    # Write output
    output_path.parent.mkdir(parents=True, exist_ok=True)
    with open(output_path, "w") as f:
        f.write(code)

    print(f"✓ Generated {output_path}")


def main():
    """Generate all TypeScript modules from JSON."""
    root = Path(__file__).parent.parent
    definitions_dir = root / "definitions"

    generate_archetypes(
        definitions_dir / "archetypes.json",
        root / "web" / "src" / "data" / "archetypes.generated.ts",
    )

    generate_scenarios(
        definitions_dir / "scenarios.json",
        root / "web" / "src" / "utils" / "scenarioGenerator.generated.ts",
    )

    print("\n✓ TypeScript code generation complete!")


if __name__ == "__main__":
    main()
