"""
Scenario definitions - GENERATED FILE

This file is automatically generated from definitions/scenarios.json
DO NOT EDIT MANUALLY - changes will be overwritten

To modify scenarios, edit definitions/scenarios.json and run:
    python scripts/generate_python.py

Parameter names match Rust implementation (bucket-brigade-core/src/scenarios.rs)
"""

from dataclasses import dataclass
import numpy as np


@dataclass
class Scenario:
    """Represents the stochastic configuration of a game.

    All parameter names match the Rust implementation for consistency.
    """

    # Fire dynamics
    prob_fire_spreads_to_neighbor: float  # Probability fire spreads to adjacent house
    prob_solo_agent_extinguishes_fire: float  # Probability one agent extinguishes fire
    prob_house_catches_fire: float  # Probability house catches fire each night

    # Team scoring (collective outcome)
    team_reward_house_survives: float  # Team reward for each house that survives
    team_penalty_house_burns: float  # Team penalty for each house that burns

    # Individual rewards (ownership-based)
    reward_own_house_survives: float  # Individual reward when own house survives
    reward_other_house_survives: float  # Individual reward when other house survives
    penalty_own_house_burns: float  # Individual penalty when own house burns
    penalty_other_house_burns: float  # Individual penalty when other house burns

    # Costs and structure
    cost_to_work_one_night: float  # Cost incurred when agent chooses to work
    min_nights: int  # Minimum nights before game can end

    # Game setup
    num_agents: int  # Number of agents participating

    def to_feature_vector(self) -> np.ndarray:
        """
        Convert scenario parameters to a feature vector for agent conditioning.
        Returns a numpy array with scenario features.
        """
        return np.array(
            [
                self.prob_fire_spreads_to_neighbor,
                self.prob_solo_agent_extinguishes_fire,
                self.prob_house_catches_fire,
                self.team_reward_house_survives,
                self.team_penalty_house_burns,
                self.reward_own_house_survives,
                self.reward_other_house_survives,
                self.penalty_own_house_burns,
                self.penalty_other_house_burns,
                self.cost_to_work_one_night,
                self.min_nights,
                self.num_agents,
            ],
            dtype=np.float32,
        )


def default_scenario(num_agents: int) -> Scenario:
    """Standard balanced scenario for general testing"""
    return Scenario(
        prob_fire_spreads_to_neighbor=0.25,
        prob_solo_agent_extinguishes_fire=0.5,
        prob_house_catches_fire=0.02,
        team_reward_house_survives=100.0,
        team_penalty_house_burns=100.0,
        reward_own_house_survives=100.0,
        reward_other_house_survives=50.0,
        penalty_own_house_burns=0.0,
        penalty_other_house_burns=0.0,
        cost_to_work_one_night=0.5,
        min_nights=12,
        num_agents=num_agents,
    )


def easy_scenario(num_agents: int) -> Scenario:
    """Low difficulty with favorable conditions - low fire spread, high extinguish rate"""
    return Scenario(
        prob_fire_spreads_to_neighbor=0.1,
        prob_solo_agent_extinguishes_fire=0.8,
        prob_house_catches_fire=0.01,
        team_reward_house_survives=100.0,
        team_penalty_house_burns=100.0,
        reward_own_house_survives=100.0,
        reward_other_house_survives=50.0,
        penalty_own_house_burns=0.0,
        penalty_other_house_burns=0.0,
        cost_to_work_one_night=0.5,
        min_nights=10,
        num_agents=num_agents,
    )


def hard_scenario(num_agents: int) -> Scenario:
    """High difficulty with challenging conditions - high fire spread, low extinguish rate"""
    return Scenario(
        prob_fire_spreads_to_neighbor=0.4,
        prob_solo_agent_extinguishes_fire=0.3,
        prob_house_catches_fire=0.05,
        team_reward_house_survives=100.0,
        team_penalty_house_burns=100.0,
        reward_own_house_survives=100.0,
        reward_other_house_survives=50.0,
        penalty_own_house_burns=0.0,
        penalty_other_house_burns=0.0,
        cost_to_work_one_night=0.5,
        min_nights=15,
        num_agents=num_agents,
    )


def trivial_cooperation_scenario(num_agents: int) -> Scenario:
    """Easy fires reward universal cooperation"""
    return Scenario(
        prob_fire_spreads_to_neighbor=0.15,
        prob_solo_agent_extinguishes_fire=0.9,
        prob_house_catches_fire=0.0,
        team_reward_house_survives=100.0,
        team_penalty_house_burns=100.0,
        reward_own_house_survives=100.0,
        reward_other_house_survives=50.0,
        penalty_own_house_burns=0.0,
        penalty_other_house_burns=0.0,
        cost_to_work_one_night=0.5,
        min_nights=12,
        num_agents=num_agents,
    )


def early_containment_scenario(num_agents: int) -> Scenario:
    """Fires start aggressive but can be stopped early"""
    return Scenario(
        prob_fire_spreads_to_neighbor=0.35,
        prob_solo_agent_extinguishes_fire=0.6,
        prob_house_catches_fire=0.02,
        team_reward_house_survives=100.0,
        team_penalty_house_burns=100.0,
        reward_own_house_survives=100.0,
        reward_other_house_survives=50.0,
        penalty_own_house_burns=0.0,
        penalty_other_house_burns=0.0,
        cost_to_work_one_night=0.5,
        min_nights=12,
        num_agents=num_agents,
    )


def greedy_neighbor_scenario(num_agents: int) -> Scenario:
    """Social dilemma between self-interest and cooperation"""
    return Scenario(
        prob_fire_spreads_to_neighbor=0.15,
        prob_solo_agent_extinguishes_fire=0.4,
        prob_house_catches_fire=0.02,
        team_reward_house_survives=100.0,
        team_penalty_house_burns=100.0,
        reward_own_house_survives=100.0,
        reward_other_house_survives=50.0,
        penalty_own_house_burns=0.0,
        penalty_other_house_burns=0.0,
        cost_to_work_one_night=1.0,
        min_nights=12,
        num_agents=num_agents,
    )


def sparse_heroics_scenario(num_agents: int) -> Scenario:
    """Few workers can make the difference"""
    return Scenario(
        prob_fire_spreads_to_neighbor=0.1,
        prob_solo_agent_extinguishes_fire=0.5,
        prob_house_catches_fire=0.02,
        team_reward_house_survives=100.0,
        team_penalty_house_burns=100.0,
        reward_own_house_survives=100.0,
        reward_other_house_survives=50.0,
        penalty_own_house_burns=0.0,
        penalty_other_house_burns=0.0,
        cost_to_work_one_night=0.8,
        min_nights=20,
        num_agents=num_agents,
    )


def rest_trap_scenario(num_agents: int) -> Scenario:
    """Fires usually extinguish themselves, but not always"""
    return Scenario(
        prob_fire_spreads_to_neighbor=0.05,
        prob_solo_agent_extinguishes_fire=0.95,
        prob_house_catches_fire=0.02,
        team_reward_house_survives=100.0,
        team_penalty_house_burns=100.0,
        reward_own_house_survives=100.0,
        reward_other_house_survives=50.0,
        penalty_own_house_burns=0.0,
        penalty_other_house_burns=0.0,
        cost_to_work_one_night=0.2,
        min_nights=12,
        num_agents=num_agents,
    )


def chain_reaction_scenario(num_agents: int) -> Scenario:
    """High spread demands distributed firefighting teams"""
    return Scenario(
        prob_fire_spreads_to_neighbor=0.45,
        prob_solo_agent_extinguishes_fire=0.6,
        prob_house_catches_fire=0.03,
        team_reward_house_survives=100.0,
        team_penalty_house_burns=100.0,
        reward_own_house_survives=100.0,
        reward_other_house_survives=50.0,
        penalty_own_house_burns=0.0,
        penalty_other_house_burns=0.0,
        cost_to_work_one_night=0.7,
        min_nights=15,
        num_agents=num_agents,
    )


def deceptive_calm_scenario(num_agents: int) -> Scenario:
    """Honest signaling rewarded during occasional flare-ups"""
    return Scenario(
        prob_fire_spreads_to_neighbor=0.25,
        prob_solo_agent_extinguishes_fire=0.6,
        prob_house_catches_fire=0.05,
        team_reward_house_survives=100.0,
        team_penalty_house_burns=100.0,
        reward_own_house_survives=100.0,
        reward_other_house_survives=50.0,
        penalty_own_house_burns=0.0,
        penalty_other_house_burns=0.0,
        cost_to_work_one_night=0.4,
        min_nights=20,
        num_agents=num_agents,
    )


def overcrowding_scenario(num_agents: int) -> Scenario:
    """Too many workers reduce efficiency"""
    return Scenario(
        prob_fire_spreads_to_neighbor=0.2,
        prob_solo_agent_extinguishes_fire=0.3,
        prob_house_catches_fire=0.02,
        team_reward_house_survives=50.0,
        team_penalty_house_burns=100.0,
        reward_own_house_survives=100.0,
        reward_other_house_survives=50.0,
        penalty_own_house_burns=0.0,
        penalty_other_house_burns=0.0,
        cost_to_work_one_night=0.6,
        min_nights=12,
        num_agents=num_agents,
    )


def mixed_motivation_scenario(num_agents: int) -> Scenario:
    """House ownership creates conflicting incentives"""
    return Scenario(
        prob_fire_spreads_to_neighbor=0.3,
        prob_solo_agent_extinguishes_fire=0.5,
        prob_house_catches_fire=0.03,
        team_reward_house_survives=100.0,
        team_penalty_house_burns=100.0,
        reward_own_house_survives=100.0,
        reward_other_house_survives=50.0,
        penalty_own_house_burns=0.0,
        penalty_other_house_burns=0.0,
        cost_to_work_one_night=0.6,
        min_nights=15,
        num_agents=num_agents,
    )



# Registry of all scenarios
SCENARIO_REGISTRY = {
    "default": default_scenario,
    "easy": easy_scenario,
    "hard": hard_scenario,
    "trivial_cooperation": trivial_cooperation_scenario,
    "early_containment": early_containment_scenario,
    "greedy_neighbor": greedy_neighbor_scenario,
    "sparse_heroics": sparse_heroics_scenario,
    "rest_trap": rest_trap_scenario,
    "chain_reaction": chain_reaction_scenario,
    "deceptive_calm": deceptive_calm_scenario,
    "overcrowding": overcrowding_scenario,
    "mixed_motivation": mixed_motivation_scenario,
}



def get_scenario_by_name(name: str, num_agents: int) -> Scenario:
    """
    Get a scenario by name.

    Args:
        name: Scenario name (e.g., "trivial_cooperation", "default")
        num_agents: Number of agents in the scenario

    Returns:
        Scenario object

    Raises:
        ValueError: If scenario name is invalid

    Example:
        >>> scenario = get_scenario_by_name("trivial_cooperation", num_agents=4)
    """
    if name not in SCENARIO_REGISTRY:
        valid_names = ", ".join(sorted(SCENARIO_REGISTRY.keys()))
        raise ValueError(f"Unknown scenario '{name}'. Valid options: {valid_names}")

    return SCENARIO_REGISTRY[name](num_agents)


def list_scenarios() -> list:
    """
    Get list of available scenario names.

    Returns:
        Sorted list of scenario names

    Example:
        >>> scenarios = list_scenarios()
        >>> print(scenarios)
        ['chain_reaction', 'deceptive_calm', 'default', ...]
    """
    return sorted(SCENARIO_REGISTRY.keys())
